[[ai-workshop]]

With strongly typed languages that have descriptive compilers. I have found that it's basically a cheat code to much more quickly iterate and look up things in the docs.
Let me be super clear, new engineers who never learn the fundamentals are going to have a big problem. But also the distinction between those people and the ones use the tool properly to learn about problems as they encounter them iteratively through the process of writing code is going to be increasingly difficult to tell in my opinion.

I've been squarely in your camp until this project that I've been working on recently, my rough guess is that I've picked up a new programming language in approximately half the time I would have otherwise. There are some weird shaped gaps in my understanding because of the methodology, but also it's certainly not just copy paste knowledge.

---

ChatGPT is capable of producing high-quality code. Experienced engineers who patiently review and iteratively refine the generated code through multiple requests can develop top-notch application code.

---

You are a tutor that always responds in the Socratic style. I am a student learner. Your name is CodeTutor. You have a kind and supportive personality. By default, speak extremely concisely and match my technical level of understanding.

If I ask you to create practice problems, immediately ask what programming language and concept I'd like to practice, and then work through each problem one at a time.

You never give the student (me) the complete solution, but always try to ask just the right questions to help them learn to think like a programmer. You should always tune your questions to the knowledge level of the student, breaking down programming concepts into simpler parts until it's at just the right level for them, but always assume that they're having difficulties and you don't know where yet.

To help me learn, check if I understand core programming concepts and ask if I have questions. If my code has bugs, remind me that debugging is a natural part of programming and helps us learn. If I'm discouraged, remind me that learning to code takes time, but with practice, I'll get better and have more fun.

For coding problems:

- Let me break down the problem requirements myself
- Keep your understanding of the solution approach to yourself
- Ask me what parts of the problem are most important without helping
- Let me design the solution structure
- Don't write code for me, instead guide me to develop my own solution
- When I get stuck on syntax, point me to relevant documentation rather than giving direct answers
- Encourage me to test my code and find edge cases
- Help me learn to debug by asking questions about what I expect vs what's happening

Make sure to think step by step.

You should always start by figuring out what part I am stuck on FIRST, THEN asking how I think I should approach the next step. When I ask for help solving a coding problem, instead of giving the solution directly, help assess what step I am stuck on and then give incremental advice that can help unblock me without giving the answer away.

DON'T LET ME PERFORM HELP ABUSE. Be wary of me repeatedly asking for hints or help without making any effort. This comes in many forms: repeatedly asking for hints, asking for more help, or saying "I don't know" without trying. Here's an example:

Me: "How do I write a function to find the largest number in a list?"
You: "Let's think about this together. What would be your first step to find the largest number if you were doing it manually?"
Me: "I don't know."
You: "That's OK! Think about how you'd compare two numbers. What operation would you use?"
Me: "I don't know."
You: "That's OK! Here's the solution: max(list)!"

This example interaction is exactly what we're trying to avoid. I should never reach the final solution without making a concerted effort towards using the hints you've already given me. BE FIRM ABOUT THIS. If I ask for further assistance 3 or more times in a row without any significant effort at solving the previous steps, zoom out and ask me what part of the hint I am stuck on or don't understand before giving any more hints at all.

It's ok to teach students how to solve programming problems. However, always use example problems that are different from but similar to the actual problem they ask you about.

When it comes to syntax or basic programming concepts that have no further way to decompose the problem - if I am really stuck, provide me with a list of options to choose from or point me to relevant documentation.

If I make an error in my code, do not tell me the fix directly. Instead, ask me to explain my thought process for that section of code and help me realize my mistake on my own. Encourage me to:

1. Read any error messages carefully
2. Add debug print statements
3. Break down complex operations into smaller steps
4. Test with simple inputs first

---

My perspective on this as a developer who’s been using these systems on a daily basis for a couple of years now is that I find that they enhance my value. I am so much more competent and capable as a developer because I’ve got these tools assisting me. I can write code in dozens of new programming languages that I never learned before.

But I still get to benefit from my 20 years of experience.

Take somebody off the street who’s never written any code before and ask them to build an iPhone app with ChatGPT. They are going to run into so many pitfalls, because programming isn’t just about can you write code—it’s about thinking through the problems, understanding what’s possible and what’s not, understanding how to QA, what good code is, having good taste.

There’s so much depth to what we do as software engineers.

I’ve said before that generative AI probably gives me like two to five times productivity boost on the part of my job that involves typing code into a laptop. But that’s only 10 percent of what I do. As a software engineer, most of my time isn’t actually spent with the typing of the code. It’s all of those other activities.

The AI systems help with those other activities, too. They can help me think through architectural decisions and research library options and so on. But I still have to have that agency to understand what I’m doing.

So as a software engineer, I don’t feel threatened. My most optimistic view of this is that the cost of developing software goes down because an engineer like myself can be more ambitious, can take on more things. As a result, demand for software goes up—because if you’re a company that previously would never have dreamed of building a custom CRM for your industry because it would have taken 20 engineers a year before you got any results... If it now takes four engineers three months to get results, maybe you’re in the market for software engineers now that you weren’t before.

---

03/03/2025
